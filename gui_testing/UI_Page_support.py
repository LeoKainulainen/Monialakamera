#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 4.21
#  in conjunction with Tcl version 8.6
#    Mar 08, 2019 07:29:48 AM EET  platform: Linux

import sys
import os

import time
import cv2
import numpy as np

# For Tkinter Image Display

from PIL import Image
from PIL import ImageTk

from UI_timing_functions import Clock
sys.path.append(
    os.path.abspath(os.path.join(os.path.dirname(__file__), os.path.pardir)))
# from LinescanRecord import UI_IDS_functions as UI_IDS_f

# from LinescanRecord.UI_IDS_functions import IDSSettings, IDSPreview, IDSPreview_standalone
# from LinescanRecord.UI_IDS_functions import IDSPreview_stop

#Linescann
from LinescanRecord.UI_IDS_functions3 import IDSSettings, IDSPreview2, IDSPreview_standalone
from LinescanRecord.UI_IDS_functions3 import IDSPreview_stop


from pyueye import ueye
from IDSCapture.pyueye_camera import Camera
from IDSCapture.pyueye_utils import FrameThread, ImageBuffer, ImageData
from multiprocessing import Pipe


try:
    import Tkinter as tk
except ImportError:
    import tkinter as tk

try:
    import ttk
    py3 = False
except ImportError:
    import tkinter.ttk as ttk
    py3 = True

def set_Tk_var():
    global StripScrollbarNumFrames
    StripScrollbarNumFrames = tk.DoubleVar()
    global CaptureSensitivityScale
    CaptureSensitivityScale = tk.DoubleVar()
    global FinishDirection
    FinishDirection = tk.StringVar()
    global che88
    che88 = tk.StringVar()
    global IDSFramerateScale
    IDSFramerateScale = tk.DoubleVar()

def k5FramesGoBack():
    print('UI_Page_support.k5FramesGoBack')
    sys.stdout.flush()

def k5FramesGoForward():
    print('UI_Page_support.k5FramesGoForward')
    sys.stdout.flush()

def CapturePauseResume():
    print('UI_Page_support.CapturePauseResume')
    sys.stdout.flush()

def FinishDirectionLtoR():
    print('UI_Page_support.FinishDirectionLtoR')
    sys.stdout.flush()

def FinishDirectionRtoL():
    print('UI_Page_support.FinishDirectionRtoL')
    sys.stdout.flush()

def process_image(self, image_data):
    # reshape the image data as 1dimensional array
    image = image_data.as_1d_image()
    # make a gray image
    # image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    # image = cv2.medianBlur(image,5)
    # find circles in the image
    # circles = cv2.HoughCircles(image, cv2.HOUGH_GRADIENT, 1.2, 100)
    # make a color image again to mark the circles in green
    # image = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)

    # if circles is not None:
    #     # convert the (x, y) coordinates and radius of the circles to integers
    #     circles = np.round(circles[0, :]).astype("int")
    #     # loop over the (x, y) coordinates and radius of the circles
    #     for (x, y, r) in circles:
    #         # draw the circle in the output image, then draw a rectangle
    #         # corresponding to the center of the circle
    #         cv2.circle(image, (x, y), r, (0, 255, 0), 6)

    print(image_data)
    # show the image with Qt
    return image
    # return QtGui.QImage(image.data,
    #                     image_data.mem_info.width,
    #                     image_data.mem_info.height,
    #                     QtGui.QImage.Format_RGB888)


def IDSStartPreview():
    print('UI_Page_support.IDSStartPreview')
    sys.stdout.flush()
    global PreviewStatus
    PreviewStatus = False
    IDSPreview2()
    # IDSCapturePreview()

def IDSCapturePreview():
    max_frames = 500
    global PreviewStatus
    if PreviewStatus != True:
        # Begin IDS Video Capture and display via hstack

        parent_conn, child_conn = Pipe()
        cpt = 0
        # max_frames = int(input("How many pictures would you like?: "))
        # max_frames = 500

        # camera class to simplify uEye API access
        cam = Camera()
        cam.init()
        cam.set_colormode(ueye.IS_CM_BGR8_PACKED)
        cam.set_aoi(0, 0, 0, 2, "centered")

        cam.set_full_auto()

        cam.set_auto_pixelclock_framerate(420,500)



        cam.alloc()
        cam.capture_video()


        # a thread that waits for new images and processes all connected views
        thread = FrameThread(cam, child_conn)

        thread.start()
        # global PreviewStatus
        PreviewStatus = True
        print("Start camera",PreviewStatus)

        # keep repeating this
    elif PreviewStatus == True:

        slices = []
        slices.clear()
        while cpt < max_frames:
            img = parent_conn.recv()



            slices.append(img)

            # cv.imwrite('train_file/image%04i.jpg' %cpt, img)

            #print(input_q.qsize())

            time.sleep(5)
            cpt += 1


        img = np.vstack(slices)

        img = cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)
        cv2.imshow("Image", img)

        cv2.waitKey(200)
        print("image captured")
        print("Capture",PreviewStatus)

        # Set Tkinter Preview canvas

        # w.IDSPreviewCanvas2.create_image(image=img)

        IDSCapturePreview()
        # thread.stop()



def IDSStopPreview():
    print('UI_Page_support.IDSStopPreview')
    sys.stdout.flush()
    IDSPreview_stop()

    PreviewStatus = False
    print("Strop Preview",PreviewStatus)
    # -------------------------------
    thread.stop()
    thread.join()

    cam.stop_video()
    cam.exit()

def LoadParticipantsCSV():
    print('UI_Page_support.LoadParticipantsCSV')
    sys.stdout.flush()

def SaveResultsCSV():
    print('UI_Page_support.SaveResultsCSV')
    sys.stdout.flush()

def StripDetectYoloV3():
    print('UI_Page_support.StripDetectYoloV3')
    sys.stdout.flush()

def StripGoLeft():
    print('UI_Page_support.StripGoLeft')
    sys.stdout.flush()

def StripGoRight():
    print('UI_Page_support.StripGoRight')
    sys.stdout.flush()

def StripShowNormal():
    print('UI_Page_support.StripShowNormal')
    sys.stdout.flush()

def TimerStart():
    print('UI_Page_support.TimerStart')
    sys.stdout.flush()
    # Timerstarted = 1
    TimerTime = Clock(w)
    TimerTime.TimerStart()
    # TimerTime.TimerTick()

def TimerStop():
    print('UI_Page_support.TimerStop')
    sys.stdout.flush()
    Clock(w).TimerStop()
    print("testing")

def OneTimerStartStop():
    TimerTime = Clock(w)
    TimerTime.TimerStart()




def init(top, gui, *args, **kwargs):
    global w, top_level, root
    w = gui
    top_level = top
    root = top
    Clock(w).Ticking()


def destroy_window():
    # Function which closes the window.
    global top_level
    top_level.destroy()
    top_level = None

if __name__ == '__main__':
    import UI_Page
    UI_Page.vp_start_gui()
